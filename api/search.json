[{"id":"10be6ba17a189071ff3c4ecf77a6208e","title":"在服务器上搭建视频文件分发服务","content":"在服务器上搭建视频文件分发服务（FTP + Nginx）在开发前后端分离项目时，经常需要将静态资源如视频、文件等集中管理和访问。本篇记录如何在 Linux 服务器上创建一个 video 文件夹，配置 FTP 服务进行上传管理，并使用 Nginx 搭建文件下载站，实现前端直接访问链接播放视频的需求。\n一、目标说明✅ 在服务器上创建 &#x2F;home&#x2F;video 文件夹，用于存储视频资源\n✅ 配置 FTP 服务（vsftpd），方便上传管理视频\n✅ 使用 Nginx 映射该文件夹，实现网页可访问下载\n✅ 前端使用直接链接 https://yourdomain.com/video/xxx.mp4 播放视频\n二、创建视频文件夹123sudo mkdir /home/videosudo chown -R www-data:www-data /home/videosudo chmod -R 755 /home/video\n✅ 如果你想通过 FTP 上传并非 www-data 用户，也可以给对应用户授权（见下方 FTP 配置）。三、配置 FTP 服务（vsftpd）1. 安装 vsftpd12sudo apt updatesudo apt install vsftpd -y\n2. 添加 FTP 用户（用于上传）12sudo adduser ftpusersudo passwd ftpuser\n把 &#x2F;home&#x2F;video 设置为 ftpuser 的主目录：\n12sudo usermod -d /home/video ftpusersudo chown -R ftpuser:ftpuser /home/video\n3. 编辑 vsftpd 配置文件1sudo nano /etc/vsftpd.conf\n修改或添加以下内容：\n1234567891011listen=YESlisten_ipv6=NOanonymous_enable=NOlocal_enable=YESwrite_enable=YESlocal_umask=022chroot_local_user=YESallow_writeable_chroot=YESpasv_enable=YESpasv_min_port=30000pasv_max_port=30100\n保存并重启服务：\n1sudo systemctl restart vsftpd\n✅ 你现在可以通过 FTP 工具（如 FileZilla）连接服务器上传视频文件到 &#x2F;home&#x2F;video 目录了。四、配置 Nginx 静态文件下载站1. 修改 Nginx 配置文件假设你已经部署了 Nginx，打开你的网站配置：\n1sudo nano /etc/nginx/sites-available/default\n在 server 块中添加一段：\n123456location /video/ &#123;    alias /home/video/;    autoindex on;    add_header Content-Disposition &quot;inline&quot;;    add_header Access-Control-Allow-Origin *;&#125;\n2. 检查配置并重载 Nginx12sudo nginx -tsudo systemctl reload nginx\n3. 访问测试现在你可以通过以下地址直接访问或播放视频了：\n1https://yourdomain.com/video/demo.mp4\n浏览器访问 &#x2F;video&#x2F; 目录还可以列出文件清单（如果 autoindex 打开）。\n五、前端链接修改在 React 或 Vue 项目中，只需将视频资源链接改成：\n1&lt;video src=&quot;https://yourdomain.com/video/sample.mp4&quot; controls /&gt;\n无需额外配置跨域，若接口为不同源，也可以通过 add_header Access-Control-Allow-Origin * 保证资源可访问。\n六、其他建议✅ 视频较多建议按日期或类别分文件夹上传，便于管理\n✅ 可配合定时任务（cron）清理过期视频文件\n✅ 如果你对权限有特殊需求，可单独创建用户组并控制文件访问\n七、总结通过本文配置，视频资源的上传、管理和前端访问将变得简单高效。适用于博客、后台管理系统、媒体内容平台等场景，结合 FTP 与 Nginx 的优势，即方便管理也支持高并发访问。\n如有更多需求，例如用户上传、权限管理、下载鉴权等，也可以进一步集成 Flask 或 Django 等后端服务做二次开发。\n","slug":"vedioStorage","date":"2025-07-10T14:31:23.000Z","categories_index":"","tags_index":"服务搭建,ftp","author_index":"Mess1A"},{"id":"f2cb4d90a926fecafd5804ed8b8967f5","title":"Flask项目服务器部署","content":"🚀 Flask 项目部署教程（使用 Gunicorn + Nginx + HTTPS）本教程介绍如何在 Ubuntu 服务器上使用 Gunicorn + Nginx 部署 Flask 后端，并实现自定义域名绑定、HTTPS 自动签发及前端 Vercel 发布。\n🧱 项目结构概览toolBackend&#x2F;           # Flask 后端项目toolFrontend&#x2F;          # React 前端项目（已托管 GitHub）\n✅ 前提条件一台 Ubuntu 服务器（推荐 20.04+）\n已安装 Python3、pip、git\n已绑定域名（如：48api.tool4me.cn）\n已解析 A 记录至服务器公网 IP\n📦 1. 安装依赖12sudo apt updatesudo apt install nginx certbot python3-certbot-nginx\n推荐使用虚拟环境管理依赖：\n123python3 -m venv venvsource venv/bin/activatepip install -r requirements.txt\n⚙️ 2. 使用 Gunicorn 启动 Flask 项目12gunicorn app:app --bind 127.0.0.1:5000 --workers 4 --daemonapp:app 表示：app.py 中的 app 实例\n\n可将其写入 systemd 服务实现守护进程管理（可选）\n🌐 3. 配置 Nginx 反向代理编辑配置文件：\n1sudo nano /etc/nginx/sites-available/your.domain.com\n内容示例：\n12345678910server &#123;    listen 80;    server_name your.domain.com;    location / &#123;        proxy_pass http://127.0.0.1:5000;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;    &#125;&#125;\n创建软链接启用：\n123sudo ln -s /etc/nginx/sites-available/your.domain.com /etc/nginx/sites-enabled/sudo nginx -tsudo systemctl reload nginx\n🔒 4. 配置 HTTPS（Let’s Encrypt）使用 certbot 自动签发证书：\n1sudo certbot --nginx -d your.domain.com\n证书自动续期设置：\n1sudo systemctl status certbot.timer  # 默认已启用自动续期\n🌍 5. 前端部署到 Vercel登录 vercel.com\n绑定你的 GitHub 仓库（如：toolFrontend）\n设置环境变量（如：API_URL 指向你的后端）\n自动部署成功后绑定自定义域名（如：tool4me.cn）\n🛡️ 6. 安全优化建议（可选）配置 fail2ban 防爆破\n使用 ufw 开启防火墙，仅开放 80 和 443 端口\n定期备份 MongoDB 数据和日志文件\n🎯 效果验证后端 API 可通过 https://your.domain.com/api/xxx 访问\n前端网页可通过 https://domain.com 访问\n数据传输加密、全球 CDN 加速生效\n👨‍💻 技术栈回顾模块\t技术栈后端\tFlask + Gunicorn + MongoDB前端\tReact + Semi Design + Vercel部署\tNginx + certbot + systemd域名 &amp; 安全\tDNSPod + Let’s Encrypt\n","slug":"flaskDeploy","date":"2025-07-10T14:31:23.000Z","categories_index":"","tags_index":"服务器部署","author_index":"Mess1A"},{"id":"c86bd12937c2148f53e2425d8c90df48","title":"丝芭商城切票","content":"\n\n\n\n\n\n\nWARNING\n本系统仅适用于丝芭商城，未测试，不保证可行性，重点介绍playwright。本系统爬虫仅用于学习交流，请勿用于非法用途。\n\n丝芭商城门票抢购项目简介本项目旨在使用playwright技术 自动化购买丝芭公演门票 。  \n功能介绍\n自动购买门票：调用购买api接口，实现自动化购买。  \nplaywright 支持：相比于selenium，playwright 更加适合自动化测试，速度更快，更稳定。  \n多线程优化：提升请求效率，减少等待时间。  \n防反爬策略：加入请求间隔控制，降低被封风险。\n\n代码主要实现部分🎯 1.playwright安装📜 代码实现12345# 安装playwrightpip install playwright# 安装playwright所需的浏览器插件playwright install\n\n🎯 2.playwright启动浏览器📜 代码实现1234567891011121314151617181920async with async_playwright() as p:    # 以无头模式运行 可更换启动的浏览器    browser = await p.chromium.launch(executable_path=&quot;.\\ms-playwright\\chromium-1169\\chrome-win\\chrome.exe&quot;, headless=False)    context = await browser.new_context()    page = await context.new_page()    try:        # ✅ 用于 API 请求的独立 context        api_context = await p.request.new_context()        ###  页面操作代码        ###  页面操作代码        await asyncio.sleep(60)  # 保持页面一段时间，便于观察        await browser.close()    except Exception as e:        print(&quot;异常或浏览器关闭:&quot;, e)    finally:        await browser.close()\n\n🎯 3.playwright调用购票接口📌 函数：make_request_with_retries此函数用于调用购票api，直到成功&#x2F;没有库存，并将返回的信息保存成日志，并返回日志信息。  \n📌 函数参数\ncontext: APIRequestContext：必须为APIRequestContext类型，其他类型没有get&#x2F;post方法。  \nticket_Add_url：购票url。  \nticket_Add_params：接口传参。  \nticket_Add_headers：请求头。\n\n📜 代码实现1234567891011121314151617181920212223242526272829303132async with async_playwright(context: APIRequestContext, ticket_Add_url, ticket_Add_params, ticket_Add_headers) as p:    retries = 0    backoff = 0.2    while retries &lt; max_retries:        try:            response = await context.post(ticket_Add_url, params=ticket_Add_params, headers=ticket_Add_headers)            current_time = datetime.now()            if response.ok:                data = await response.json()                if &#x27;success&#x27; in data.get(&quot;Message&quot;, &quot;&quot;):                    log_entry = f&quot;数据=&#123;data&#125;&quot;                    log_data.append(log_entry)                    return log_data                else:                    log_entry = f&quot;数据=&#123;data&#125;&quot;                    log_data.append(log_entry)                    retries += 1                    delay = backoff * (2 ** retries) + random.random()*0.1                    await asyncio.sleep(delay)            else:                error_entry = f&quot;状态码: &#123;response.status&#125;&quot;                log_data.append(error_entry)                retries += 1                delay = backoff * (2 ** retries) + random.random()*0.1                await asyncio.sleep(delay)        except Exception as e:            error_entry = f&quot;&#123;e&#125;&quot;            log_data.append(error_entry)            retries += 1            delay = backoff * (2 ** retries) + random.random()*0.1            await asyncio.sleep(delay)    return log_data","slug":"ticketPlayWright","date":"2025-06-10T16:00:00.000Z","categories_index":"","tags_index":"python,爬虫,playwright","author_index":"Mess1A"},{"id":"f3519b3c4b337b4d2b1c684904d9f509","title":"丝芭商城竞价数据统计","content":"\n\n\n\n\n\n\nWARNING\n本系统仅适用于丝芭商城，其他商城请自行修改代码。本系统爬虫仅用于学习交流，请勿用于非法用途。\n\n丝芭商城数据导出工具项目简介本项目是一个用于 自动化抓取和导出丝芭商城（https://shop.48.cn）拍卖数据 的 Python 工具。用户可以获取 指定拍卖页面 的信息，并将其整理后导出为 Excel 文件。  \n功能介绍\n自动获取拍卖数据：解析商品详情页，提取关键信息，如竞拍价格、出价记录等。  \n数据存储：将抓取的数据存入 Excel，方便后续分析。  \nTampermonkey 脚本支持：支持在浏览器中使用 Tampermonkey 直接获取数据。  \n多线程优化：提升请求效率，减少等待时间。  \n防反爬策略：加入请求间隔控制，降低被封风险。\n\n代码主要实现部分🎯 1.获取竞价成功与失败数据📌 函数：auto_bid_until_end此函数用于自动执行竞价过程，直到达到指定的成功竞价数量，并收集所有竞价数据，包括成功和失败的竞价信息。  \n📌 函数参数\ndriver：WebDriver 实例，用于与网页交互。  \ntarget_successful_count：目标成功竞价的数量。  \nbid_type：竞价类型（座位类别）。  \ntheater_name：剧院名称。\n\n📜 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667def auto_bid_until_end(driver, target_successful_count, bid_type, theater_name):    successful_bids_data = []  # 存储所有成功竞价信息    unsuccessful_bids_data = []  # 存储所有未成功竞价信息    total_bids_data = []    wait = WebDriverWait(driver, 10)    # 获取最大页数    max_page_element = driver.find_element(By.XPATH, &#x27;/html/body/div[2]/div/div[3]/div[3]/div[2]/div[2]/div[4]/span[3]&#x27;)    max_page = int(max_page_element.text)    now_page = 1    # 📌 **获取成功竞价数据**    while now_page &lt;= max_page:        u_blist = driver.find_element(By.ID, &quot;u_blist&quot;)        successful_bids_data.extend(parse_successful_bids(u_blist))        if len(successful_bids_data) &gt;= target_successful_count:            print(&quot;✅ 已获取所有成功竞价信息&quot;)            break        # 检查 `u_blistM` 是否存在额外的成功竞价信息        u_blistM = driver.find_element(By.ID, &quot;u_blistM&quot;)        successful_bids_data.extend(parse_successful_bids(u_blistM))        if len(successful_bids_data) &gt;= target_successful_count:            print(&quot;✅ 已获取所有成功竞价信息&quot;)            break        # 📌 **翻页**        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, &#x27;//*[@id=&quot;a_b_n&quot;]&#x27;)))        next_button.click()        print(f&quot;🔄 加载第 &#123;now_page&#125; 页...&quot;)        now_page += 1        time.sleep(0.15)    # 📌 **获取未成功竞价数据**    while now_page &lt;= max_page:        u_blist = driver.find_element(By.ID, &quot;u_blist&quot;)        unsuccessful_bids_data.extend(parse_unsuccessful_bids(u_blist, successful_bids_data))        # 检查 `u_blistM` 是否存在额外的未成功竞价信息        u_blistM = driver.find_element(By.ID, &quot;u_blistM&quot;)        unsuccessful_bids_data.extend(parse_unsuccessful_bids(u_blistM, successful_bids_data))        # 📌 **翻页**        next_button = wait.until(EC.element_to_be_clickable((By.XPATH, &#x27;//*[@id=&quot;a_b_n&quot;]&#x27;)))        next_button.click()        print(f&quot;🔄 加载第 &#123;now_page&#125; 页...&quot;)        now_page += 1        time.sleep(0.15)    # **去重处理**    unsuccessful_bids_data = deduplication(unsuccessful_bids_data)    total_bids_data = successful_bids_data + unsuccessful_bids_data    # 📌 **获取座位信息**    seats = get_seat_positon(theater_name, bid_type, target_successful_count)    # **分配座位号**    for idx, bid in enumerate(total_bids_data):        bid[&quot;座位类型&quot;] = bid_type        if idx &gt; len(seats) - 1:            bid[&quot;座位号&quot;] = &quot;竞价失败&quot;        else:            bid[&quot;座位号&quot;] = seats[idx]  # 添加座位号    return total_bids_data\n\n🎯 2.统计当前页面竞价数据前的准备活动📌 函数：stats_one_good此函数用于获取丝芭商城的单页面下的竞价数据，并将其保存到 Excel 文件中。\n📜 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def stats_one_good(driver):    # 📌 获取剧院名称和 Excel 文件名    theater_name = driver.find_element(By.XPATH, &quot;/html/body/div[2]/div/div[2]/div[2]/ul/li[2]/p&quot;).text    excel_name = driver.find_element(By.XPATH, &quot;/html/body/div[2]/div/div[2]/div[2]/ul/li[1]&quot;).text    # 📌 获取商品标题    title_name_element = driver.find_element(By.CLASS_NAME, &quot;i_tit&quot;)    title_name = title_name_element.text.strip()  # 获取文本内容并去除首尾空格    # 📌 获取商品详细信息并判断是否为生日公演    item_info = driver.find_element(By.XPATH, &#x27;//*[@id=&quot;TabTab03Con1&quot;]&#x27;).get_attribute(&#x27;outerHTML&#x27;)    soup = BeautifulSoup(item_info, &#x27;html.parser&#x27;)    item_info_text = soup.get_text()    birthday = &quot;生日潮流包&quot; in item_info_text    # 📌 确定竞价类型    bid_type = get_seat_type(title_name)    # 📌 根据剧场和商品类型选择相应的竞价数量    if &quot;SNH&quot; in theater_name and &quot;星梦剧院&quot; in title_name and &quot;MINILIVE&quot; not in title_name:        bid_number = get_bid_number_SNH(bid_type, driver)        if birthday:            theater_name = &quot;SNHbirthday&quot;    elif &quot;SNH&quot; in theater_name and &quot;星梦空间&quot; in title_name and &quot;MINILIVE&quot; not in title_name:        bid_number = get_bid_number_HGH(bid_type)        theater_name = &quot;HGH&quot;    elif &quot;BEJ&quot; in theater_name and &quot;生日会&quot; not in title_name:        bid_number = get_bid_number_BEJ(driver)    elif &quot;MINILIVE&quot; in title_name:        bid_number = get_bid_number_MiniLive(driver)        theater_name = &quot;MINILIVE&quot;    elif &quot;拍立得&quot; in title_name:        bid_number = get_bid_number_pld(driver)        theater_name = &quot;拍立得&quot;    elif &quot;生日会&quot; in title_name:        bid_number = get_bid_number_birthparty(driver, theater_name)        theater_name = &quot;生日会&quot;    print(f&quot;🎫 竞价席位总数：&#123;bid_number&#125;&quot;)    # 📌 竞价流程    if bid_number != 0:        max_bid_num = bid_number        total_bids_data = auto_bid_until_end(driver, max_bid_num, bid_type, theater_name)        # 📌 获取商品 ID 并保存 Excel 数据        item_id = get_item_name(driver)        save_excel(total_bids_data, item_id, excel_name)    # 📌 刷新页面，准备下一次操作    driver.refresh()\n\n📊 3.保存竞价数据到 Excel📌 函数：save_excel此函数用于将竞价成功的数据保存到 Excel 文件，支持写入商品名称、表头、竞价信息，并更新统计信息（最小&#x2F;最大出价、最早&#x2F;最晚出价等）。\n📜 代码实现12345678910111213141516171819202122232425262728293031323334353637def save_excel(successful_bids_data, item_name, output_file=&quot;bidding_results.xlsx&quot;):    &quot;&quot;&quot;    将竞价成功数据保存到 Excel 文件。    :param successful_bids_data: 竞价成功的数据列表    :param item_name: 商品名称    :param output_file: 输出文件名（默认：&quot;bidding_results.xlsx&quot;）    &quot;&quot;&quot;    # 📌 将数据转换为 Pandas DataFrame    df = pd.DataFrame(successful_bids_data)        # 📌 创建 Excel 工作簿和工作表    wb = Workbook()    ws = wb.active    ws.title = &quot;Bidding Results&quot;        # 📌 在 Excel 文件的第一行写入商品名称    ws.append([item_name])        # 📌 写入表头并加粗    header = [&quot;出价状态&quot;, &quot;出价人&quot;, &quot;出价时间&quot;, &quot;出价金额&quot;, &quot;座位类型&quot;, &quot;座位号&quot;]    ws.append(header)        for cell in ws[2]:  # 第二行是标题行        cell.font = Font(bold=True)        # 📌 将竞价数据写入 Excel    for row in dataframe_to_rows(df, index=False, header=False):        ws.append(row)        # 📌 更新最小/最大出价、最早/最晚出价的出价人信息    ws = update_min_max_info(df, ws)    # 📌 保存 Excel 文件    wb.save(output_file + &quot;.xlsx&quot;)    print(f&quot;✅ 竞价成功信息已保存至 &#123;output_file&#125;.xlsx&quot;)\n\n\n\n","slug":"pythonProgram","date":"2025-03-10T14:31:23.000Z","categories_index":"","tags_index":"python,爬虫","author_index":"Mess1A"}]